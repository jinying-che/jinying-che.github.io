<!doctype html><html lang=en><head><title>HTTP :: </title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="HTTP History"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://jinying-che.github.io/posts/network/http/><link rel=stylesheet href=https://jinying-che.github.io/styles.css><link rel="shortcut icon" href=https://jinying-che.github.io/img/theme-colors/green.png><link rel=apple-touch-icon href=https://jinying-che.github.io/img/theme-colors/green.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="HTTP"><meta property="og:description" content="HTTP History"><meta property="og:url" content="https://jinying-che.github.io/posts/network/http/"><meta property="og:site_name" content><meta property="og:image" content="https://jinying-che.github.io/img/favicon/green.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2018-10-10 11:19:45 +0800 +0800"></head><body class=green><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>jinying-che:~#</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/posts>Home</a></li><li><a href=/tags>Tags</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/posts>Home</a></li><li><a href=/tags>Tags</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://jinying-che.github.io/posts/network/http/>HTTP</a></h1><div class=post-meta><time class=post-date>2018-10-10 ::</time></div><span class=post-tags>#<a href=https://jinying-che.github.io/tags/network/>network</a>&nbsp;</span><div class=post-content><div><blockquote><p>HTTP位于网络的应用层，使用TCP/IP协议进行传输</p></blockquote><ul><li>TCP连接<ul><li>HTTP/1.0：通过非标准字段<code>Connection: keep-alive</code>保持TCP连接</li><li>HTTP/1.1：允许TCP复用，但所有数据通信都是按次序的，请求要一个一个处理</li><li>HTTP/2：</li></ul></li></ul><h2 id=http09>HTTP/0.9<a href=#http09 class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li>客户端请求，服务器回复完毕，TCP连接即关闭</li><li>只有一个命令：<code>GET</code></li><li>服务器只能回应HTML格式的字符串</li></ul><h2 id=http10>HTTP/1.0<a href=#http10 class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li>加入<code>POST</code>、<code>HEAD</code>命令</li><li>协议分为头部和数据部，头部字段如：<code>Content-Type</code>、<code>Content-Encoding</code>等</li><li>为了保持TCP的复用，引入头部字段：<code>Connection: keep-alive</code></li></ul><h2 id=http11>HTTP/1.1<a href=#http11 class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li><p>TCP默认为持久连接，由客户端和服务端主动关闭</p></li><li><p>引入管道机制，向TCP连接发送多个请求（而不用等待上一个请求处理之后，再发送）</p><ul><li>服务端可以区分多个请求的基础：<code>Content-Length</code>字段，即知道每个请求的长度</li><li>在1.0版中，<code>Content-Length</code>字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。</li></ul></li><li><p>引入流模式</p><blockquote><p>对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用"流模式"（stream）取代"缓存模式"（buffer）。</p><p>因此，1.1版规定可以不使用<code>Content-Length</code>字段，而使用<a href=https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81>&ldquo;分块传输编码&rdquo;</a>（chunked transfer encoding）。只要请求或回应的头信息有<code>Transfer-Encoding</code>字段，就表明回应将由数量未定的数据块组成。</p><p><a href=http://www.ruanyifeng.com/blog/2016/08/http.html>《HTTP 协议入门》 阮一峰</a></p></blockquote><blockquote><p>当HTTP流水线启动时，后续请求都可以不用等待第一个请求的成功回应就被发送。然而HTTP流水线已被证明很难在现有的网络中实现，因为现有网络中有很多老旧的软件与现代版本的软件共存。因此，HTTP流水线已被在有多请求下表现得更稳健的HTTP/2的帧所取代。</p><p><a href=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview>《HTTP概述》 MDN</a></p></blockquote></li><li><p>服务器只能按顺序处理请求，如果前面请求处理的慢，后面的需要排队，即<a href=https://zh.wikipedia.org/wiki/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E>&ldquo;队头堵塞&rdquo;</a>（Head-of-line blocking）。</p></li></ul><h2 id=http20>HTTP/2.0<a href=#http20 class=hanchor arialabel=Anchor>&#8983;</a></h2><blockquote><p>2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。</p><p>这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。</p></blockquote><ul><li>头部和数据部都是二进制，统称为“帧”</li><li>全双工模式（双向、实时通信），客户端和服务端可同时发送多个请求和回应（解决阻塞问题）<ul><li>实现的基础：由于HTTP/2不按照顺序发送，就需要对每个请求或回应作区分，即每个请求或回应的所有数据包都对应唯一ID</li><li>客户端和服务器都可以发送信号（<code>RST_STREAM</code>帧），取消这个数据流</li></ul></li><li>头信息压缩</li><li>服务器未经允许，主动推送数据到客户端</li></ul><blockquote><p>Reference:</p><ul><li><a href=http://www.ruanyifeng.com/blog/2016/08/http.html>《HTTP 协议入门》 阮一峰</a></li><li><a href=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview>《HTTP概述》 MDN</a></li></ul></blockquote></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://jinying-che.github.io/posts/db/mysql_index/><span class=button__icon>←</span>
<span class=button__text>MySQL Index</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2024 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>