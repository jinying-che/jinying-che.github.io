<!doctype html><html lang=en><head><title>Shell Cheatsheet ::</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Cheatsheet Every Day!"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://jinying-che.github.io/posts/shell_cheatsheet/><link rel=stylesheet href=https://jinying-che.github.io/styles.css><link rel="shortcut icon" href=https://jinying-che.github.io/img/theme-colors/green.png><link rel=apple-touch-icon href=https://jinying-che.github.io/img/theme-colors/green.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Shell Cheatsheet"><meta property="og:description" content="Cheatsheet Every Day!"><meta property="og:url" content="https://jinying-che.github.io/posts/shell_cheatsheet/"><meta property="og:site_name" content><meta property="og:image" content="https://jinying-che.github.io/img/favicon/green.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2023-06-08 15:41:00 +0800 +0800"></head><body class=green><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>jinying-che:~#</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/posts>Home</a></li><li><a href=/tags>Tags</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/posts>Home</a></li><li><a href=/tags>Tags</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://jinying-che.github.io/posts/shell_cheatsheet/>Shell Cheatsheet</a></h1><div class=post-meta><time class=post-date>2023-06-08 ::</time></div><span class=post-tags>#<a href=https://jinying-che.github.io/tags/cheatsheet/>cheatsheet</a>&nbsp;
#<a href=https://jinying-che.github.io/tags/shell/>shell</a>&nbsp;</span><div class=post-content><div><p>Some skills of daily commands, they are useful but not worth creating a particular cheatsheet, so I put them here generally.</p><h3 id=fzfhttpsgithubcomjunegunnfzf--zsh><a href=https://github.com/junegunn/fzf>fzf</a> + zsh<a href=#fzfhttpsgithubcomjunegunnfzf--zsh class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Add the fzf plugin for zsh, the terminal is fully enhanced!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#f92672>- plugins=(git autojump zsh-autosuggestions zsh-syntax-highlighting)
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+ plugins=(git autojump zsh-autosuggestions zsh-syntax-highlighting fzf)
</span></span></span></code></pre></div><p>Try some comands to see the fzf integartion, e.g.</p><ul><li><code>cd **</code> + <code>TAB(key)</code></li><li><code>Ctrl</code> + <code>r</code></li><li>&mldr;</li></ul><p>Reference:</p><ul><li><a href=https://github.com/junegunn/fzf#fuzzy-completion-for-bash-and-zsh>https://github.com/junegunn/fzf#fuzzy-completion-for-bash-and-zsh</a></li></ul><h3 id=myclihttpsgithubcomdbclimycli-pager><a href=https://github.com/dbcli/mycli>mycli</a> pager<a href=#myclihttpsgithubcomdbclimycli-pager class=hanchor arialabel=Anchor>&#8983;</a></h3><p>By default, <code>mycli</code> shows the sql result in a new window (press <code>q</code> to quit and all results gone), but it would be annoyed when result needs to be kept in the current window, the behavior is controlled by <strong>Pager Configuraton</strong>.</p><p>On macOS and Linux, the pager will default to less for most users.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span><span style=color:#75715e># disable pager </span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>enable_pager</span> = <span style=color:#a6e22e>False</span> 
</span></span></code></pre></div><p>Reference:</p><ul><li><a href=https://www.mycli.net/pager>https://www.mycli.net/pager</a></li></ul><h3 id=linuxunix-os-version>linux/unix os version<a href=#linuxunix-os-version class=hanchor arialabel=Anchor>&#8983;</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>- cat /etc/os-release
</span></span><span style=display:flex><span>- lsb_release -a
</span></span></code></pre></div><h3 id=批量删除进程>批量删除进程<a href=#批量删除进程 class=hanchor arialabel=Anchor>&#8983;</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ps aux | grep redis | grep -v grep | awk <span style=color:#e6db74>&#39;{print $2}&#39;</span> | xargs kill -9
</span></span></code></pre></div><p>其中<code>awk '{print $2}' </code>是打印所有进程的<strong>pid</strong></p><h2 id=21>2>&amp;1<a href=#21 class=hanchor arialabel=Anchor>&#8983;</a></h2><p><strong>> ** ：代表重定向到哪里(</strong>><strong>：会覆盖，</strong>&#187;**：追加，不覆盖)
**1 ** ：表示stdout标准输出，系统默认值是1（<strong>0</strong>代表标准输入）
<strong>2 ** ：表示stderr标准错误
<strong>& ** ：表示等同于的意思，2>&amp;1，表示2的输出重定向等同于1（<strong>错误输出</strong>的位置同</strong>标准输出</strong>一样）</p><h2 id=heading>#!<a href=#heading class=hanchor arialabel=Anchor>&#8983;</a></h2><p><code>#!</code> 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell</p><h2 id=shell-编程>shell 编程<a href=#shell-编程 class=hanchor arialabel=Anchor>&#8983;</a></h2><h4 id=关于>关于[]<a href=#关于 class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>实际上是bash 中 test 命令的简写。即所有的 [ expr ] 等于 test expr (expr与[]之间，要有空格)</li><li>使用逻辑判断，应该是：<code>[] || []</code>和<code>[] && []</code></li></ul><h4 id=变量>变量<a href=#变量 class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>变量赋值不应有空格： <code>param=$1</code></li></ul><p>##ssh</p><ul><li><p>ssh 连接服务器</p><p><code>ssh -P port username@ip</code></p></li><li><p>ssh 使用scope复制本机文件到远程服务器</p><p><code>scope local-directory/local-file username@ip:remote-directory</code></p></li><li><p>ssh 公钥登陆流程：</p><blockquote><p>所谓"公钥登录"，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。</p></blockquote></li><li><p>打印连接<strong>debug</strong>信息(分析连接流程)： <code>ssh -v root@74.82.202.131 -p 28382</code></p><blockquote><p>-v 参数：打印debug信息</p></blockquote></li></ul><h2 id=查目录下的文件数>查目录下的文件数<a href=#查目录下的文件数 class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li>ls -all | wc -l</li></ul><blockquote><p>Linux系统中的wc(Word Count)命令的功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出。</p></blockquote><h2 id=查看二进制bin文件>查看二进制(bin)文件<a href=#查看二进制bin文件 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>For bin :</p><pre tabindex=0><code>xxd -b file
</code></pre><p>For hex :</p><pre tabindex=0><code>xxd file
</code></pre><h2 id=进程进入后台并运行>进程进入后台并运行<a href=#进程进入后台并运行 class=hanchor arialabel=Anchor>&#8983;</a></h2><blockquote><p>这是个悲伤的故事，把socket服务通过<code>ctrl-z</code>放入后台，天真地认为进程在后台运行，其实进程已被暂停</p></blockquote><ul><li>后台运行： <code>command &</code>（在命令后加**&**）</li><li>后台暂停： <code>ctrl-z</code>（将线程放入后台，并暂停其运行）</li></ul><h2 id=解压>解压<a href=#解压 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>####tar</p><ul><li>解压：<code>tar -xvf file.jar.gz</code></li><li>解压到指定文件：<ul><li><code>mkdir directory</code></li><li><code>tar -xvf file.jar.gz -C directory</code></li></ul></li><li>压缩：<code>tar -zcvf directory/filename file||directory</code></li></ul><h4 id=zip>zip<a href=#zip class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>解压：<code>gzip -d file.gz</code></li><li>压缩：<code>gzip file</code></li></ul><h2 id=linux-网络>Linux 网络<a href=#linux-网络 class=hanchor arialabel=Anchor>&#8983;</a></h2><blockquote><ul><li>nethogs: 按进程查看流量占用</li><li>iptraf: 按连接/端口查看流量</li><li>ifstat: 按设备查看流量</li><li>ethtool: 诊断工具</li><li>tcpdump: 抓包工具</li><li>ss: 连接查看工具</li><li>其他: dstat, slurm, nload, bmon</li></ul></blockquote><p>###查看tcp端口</p><ul><li>查看所有tcp端口的使用情况：<code>netstat -nptl | grep pid/port/app</code> （可能需要root权限）</li><li>check the TCP status : <code>netstat -atp</code><ul><li>For Established : <code>netstat -atp | grep ESTABLISHED</code></li><li>For Established and specific port : <code>netstat -atp | grep ESTABLISHED | grep port</code></li></ul></li><li>端口即文件：<code>lsof -i:port</code> （可能需要root权限）</li><li>For Mac: <code>netstat -an -ptcp | grep LISTEN</code></li></ul><h3 id=ss>ss<a href=#ss class=hanchor arialabel=Anchor>&#8983;</a></h3><blockquote><p>它利用到了TCP协议栈中tcp_diag。tcp_diag是一个用于分析统计的模块，可以获得Linux 内核中第一手的信息，这就确保了ss的快捷高效。当然，如果你的系统中没有tcp_diag，ss也可以正常运行，只是效率会变得稍慢</p></blockquote><p>ss的用法与netstat类似，比如<code>ss -nptl | grep pid</code></p><p>###网络配置</p><blockquote><p><a href=http://www.cnblogs.com/xiaoluo501395377/archive/2013/05/26/3100065.html>reference:</a></p><p>Linux支持将多块物理网卡绑定成一块逻辑网卡，绑定后的逻辑网卡可以并行使用组成其的所有物理网卡，通过这样的方式可以提高带宽以及网路的稳定性。</p><p>Linux下支持三种模式的网卡绑定：</p><p><strong>①模式0</strong>：<strong>平衡轮训</strong>　　使用这种模式来进行多网卡绑定时我们可以提高网络的带宽，其流量是从绑定的多块网卡上平均分配的</p><p><strong>②模式1</strong>：<strong>主动备份</strong>　　使用这种模式来进行多网卡绑定时我们可以提高网络的稳定性，这种模式不会提高网络的带宽，每次只有一块网卡在走流量，只有当这块网卡发生故障时，绑定在一起的其它物理网卡才会工作</p><p><strong>③模式3</strong>：<strong>广播模式</strong>　　这种模式一般都不用</p><p>我们如果想通过多网卡绑定来提升网络的带宽，就选择模式0，如果想提高网络的稳定性，则选择模式1</p></blockquote><p>模式由bond0配置文件中的BONDING_OPTS决定，配置文件在<code>/etc/network/network-scripts</code>路径下，文件命名可能如下：ifcfg-bond0、ifcfg-eth0、ifconfig-eth1等等</p><pre tabindex=0><code>//ifcfg-bond0 文件

DEVICE=bond0
ONBOOT=yes
BONDING_OPTS=&#34;miimon=1000 mode=1&#34; //模式选择
TYPE=Ethernet
BOOTPROTO=none
IPADDR=10.86.67.42
NETMASK=255.255.255.0
</code></pre><h3 id=端口连通性测试>端口连通性测试<a href=#端口连通性测试 class=hanchor arialabel=Anchor>&#8983;</a></h3><p><code>nc -zv ip port</code></p><p><code>telnet ip port</code></p><blockquote><p>nc 命令可起个临时的tcp服务 : <code>nc -l</code></p></blockquote><h2 id=sudo-and-su>sudo and su<a href=#sudo-and-su class=hanchor arialabel=Anchor>&#8983;</a></h2><p>####sudo vs su</p><ul><li>两个命令的最大区别是：<code>sudo</code> 命令需要输入当前用户的密码，<code>su</code> 命令需要输入 root 用户的密码</li><li>两个命令之间的另外一个区别是其默认行为。<code>sudo</code> 命令只允许使用提升的权限运行单个命令，而 <code>su</code> 命令会启动一个新的 shell，同时允许使用 root 权限运行尽可能多的命令，直到明确退出登录####</li></ul><h4 id=sudo-su>sudo su<a href=#sudo-su class=hanchor arialabel=Anchor>&#8983;</a></h4><p>以当前用户的身份（即只需要当前用户的密码），就可登录root用户，而不需要root密码</p><h4 id=su-vs-su-->su vs su -<a href=#su-vs-su-- class=hanchor arialabel=Anchor>&#8983;</a></h4><p>前者在切换到 root 用户之后仍然保持旧的（或者说原始用户的）环境，而后者则是创建一个新的环境（由 root 用户 <code>~/.bashrc</code> 文件所设置的环境），相当于使用 root 用户正常登录（从登录屏幕登录）</p><p><strong>所以推荐使用 <code>su -</code></strong></p><blockquote><p><a href=https://linux.cn/article-8404-1.html>深入理解 sudo 与 su 之间的区别</a></p></blockquote><h2 id=更改文件所属用户及用户组>更改文件所属用户及用户组<a href=#更改文件所属用户及用户组 class=hanchor arialabel=Anchor>&#8983;</a></h2><p><code>chown -R user:group file/directory</code></p><h2 id=查看文件类型>查看文件类型<a href=#查看文件类型 class=hanchor arialabel=Anchor>&#8983;</a></h2><p><code>file</code> 命令：</p><ul><li><code>file filename</code> 若显示为data，可能为压缩文件</li></ul><p>cat /etc/sysconfig/network</p><blockquote><p>解释：-R 递归修改</p></blockquote><h2 id=查看进程所在目录>查看进程所在目录<a href=#查看进程所在目录 class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=pwdx>pwdx<a href=#pwdx class=hanchor arialabel=Anchor>&#8983;</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ pwdx &lt;PID&gt;
</span></span></code></pre></div><h3 id=lsof>lsof<a href=#lsof class=hanchor arialabel=Anchor>&#8983;</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ lsof -p &lt;PID&gt; | grep cwd
</span></span></code></pre></div><h3 id=proc>/proc<a href=#proc class=hanchor arialabel=Anchor>&#8983;</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ readlink -e /proc/&lt;PID&gt;/cwd
</span></span></code></pre></div><h2 id=linux-系统参数>Linux 系统参数<a href=#linux-系统参数 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>#####一个进程文件句柄数限制</p><ul><li>查看<ul><li><code>ulimit -n</code> (默认soft)</li><li><code>ulimit -Hn</code>(hard)</li></ul></li><li>临时修改：ulimit -n 1000000，只对当前登录用户目前的使用环境有效，系统重启或用户退出后就会失效</li><li>永久修改：编辑 /etc/security/limits.conf 文件，( 修改完重新登录就可以见到)， 修改后内容为</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>* soft nofile 1000000
</span></span><span style=display:flex><span>* hard nofile 1000000
</span></span></code></pre></div><blockquote><p>soft是一个警告值，而hard则是一个真正意义的阀值，超过就会报错。soft 指的是当前系统生效的设置值。hard 表明系统中所能设定的最大值nofile - 打开文件的最大数目星号表示针对所有用户，若仅针对某个用户登录ID，替换星号。</p></blockquote><h5 id=端口数量压测客户端>端口数量（压测客户端）<a href=#端口数量压测客户端 class=hanchor arialabel=Anchor>&#8983;</a></h5><ul><li><p>查看：<code>cat /proc/sys/net/ipv4/ip_local_port_range</code></p></li><li><p>临时修改： <code>echo "1024 65535"> /proc/sys/net/ipv4/ip_local_port_range</code></p></li><li><p>永久修改：<code>/etc/sysctl.conf 增加 net.ipv4.ip_local_port_range= 1024 65535</code></p></li></ul><blockquote><p>并令其生效sysctl -p现在可以使用的端口达到64510个</p></blockquote><p>#####系统全局可用句柄数目限制</p><ul><li>查看：<code>cat /proc/sys/fs/file-max</code></li><li>当前会话修改，可以这么做：<code>echo 1048576 > /proc/sys/fs/file-max</code> 但系统重启后消失。</li><li>永久修改，要添加到 /etc/sysctl.conf 文件中：<code>fs.file-max = 1048576</code>保存并使之生效：<code>sysctl -p</code></li></ul><h2 id=top>Top<a href=#top class=hanchor arialabel=Anchor>&#8983;</a></h2><blockquote><p>以前只是在 linux 机器上使用 top 命令。常用的快键键是:</p><ul><li>p 键 - 按 cpu 使用率排序</li><li>m 键 - 按内存使用量排序</li></ul><p>这 2 个快捷键在 mac 上都不一样。对应的是，先输入 o，然后输入 cpu 则按 cpu 使用量排序，输入 rsize 则按内存使用量排序。</p><p>如果记不清了，可以在 top 的界面上按 <code>?</code>，在弹出的帮助界面中即可看到。</p></blockquote><h4 id=查看进程>查看进程<a href=#查看进程 class=hanchor arialabel=Anchor>&#8983;</a></h4><p><code>top -H -p pid</code></p><h2 id=cpu>CPU<a href=#cpu class=hanchor arialabel=Anchor>&#8983;</a></h2><h4 id=查看物理cpu个数>查看物理cpu个数<a href=#查看物理cpu个数 class=hanchor arialabel=Anchor>&#8983;</a></h4><p><code>grep 'physical id' /proc/cpuinfo | sort -u | wc -l</code></p><p>####查看核心数量</p><p><code>grep 'core id' /proc/cpuinfo | sort -u | wc -l</code></p><p>####查看线程数或逻辑CPU的个数</p><p><code>grep 'processor' /proc/cpuinfo | sort -u | wc -l</code></p><h3 id=docker中cpu的查看>Docker中cpu的查看<a href=#docker中cpu的查看 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li><code>cat /sys/fs/cgroup/cpu/cpu.cfs_quota_us</code></li><li><code>cat /sys/fs/cgroup/cpu/cpu.cfs_period_us</code></li></ul><blockquote><p><code>cfs_quota_us</code>和<code>cfs_period_us</code>两个值是联合使用的，两者的比值，即<code>cfs_quota_us</code>/<code>cfs_period_us</code>代表了该容器实际可用的做多的CPU核数。</p><p>比如<code>cfs_quota_us</code>=50000，<code>cfs_period_us</code>=100000，那么二者的比值是0.5，也就是说该容器可以使用0.5个cpu。这样的管控粒度更细，在cgroup使用systemd时最低可以到0.01核。</p></blockquote><h2 id=watch>watch<a href=#watch class=hanchor arialabel=Anchor>&#8983;</a></h2><p>watch命令默认每隔2秒执行后面参数给出的命令，也可手动指定，最小间隔0.1秒</p><p><code>watch -n 0.1 date</code>: 每隔100ms，打印日期</p><h2 id=curl>curl<a href=#curl class=hanchor arialabel=Anchor>&#8983;</a></h2><h4 id=分析http请求耗时>分析http请求耗时<a href=#分析http请求耗时 class=hanchor arialabel=Anchor>&#8983;</a></h4><ol><li><p>构建输出格式</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>    curl-format.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    time_namelookup:  %{time_namelookup}\n
</span></span><span style=display:flex><span>       time_connect:  %{time_connect}\n
</span></span><span style=display:flex><span>    time_appconnect:  %{time_appconnect}\n
</span></span><span style=display:flex><span>      time_redirect:  %{time_redirect}\n
</span></span><span style=display:flex><span>   time_pretransfer:  %{time_pretransfer}\n
</span></span><span style=display:flex><span> time_starttransfer:  %{time_starttransfer}\n
</span></span><span style=display:flex><span>                    ----------\n
</span></span><span style=display:flex><span>         time_total:  %{time_total}\n
</span></span></code></pre></div><blockquote><ul><li><code>time_namelookup</code>：DNS 域名解析的时候，就是把 <code>https://zhihu.com</code> 转换成 ip 地址的过程</li><li><code>time_connect</code>：TCP 连接建立的时间，就是三次握手的时间</li><li><code>time_appconnect</code>：SSL/SSH 等上层协议建立连接的时间，比如 connect/handshake 的时间</li><li><code>time_redirect</code>：从开始到最后一个请求事务的时间</li><li><code>time_pretransfer</code>：从请求开始到响应开始传输的时间</li><li><code>time_starttransfer</code>：从请求开始到第一个字节将要传输的时间</li><li><code>time_total</code>：这次请求花费的全部时间</li></ul></blockquote></li><li><p>curl -w &ldquo;@curl-format.txt&rdquo; -o /dev/null -s -L &ldquo;<a href=http://cizixs.com>http://cizixs.com</a>&rdquo;`</p></li></ol><h2 id=grep>grep<a href=#grep class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li>取反： <code>-v</code></li><li>Ignore case: <code>-i</code></li></ul><h2 id=lsof-1>lsof<a href=#lsof-1 class=hanchor arialabel=Anchor>&#8983;</a></h2><blockquote><p>lsof (list open files)是一个列出当前系统打开文件的工具。拥有查看你进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP)，找回/恢复删除的文件等功能</p></blockquote><p>##Shell Script</p><ul><li><p><code>lsof -i | awk '{print $2}' | sort | uniq -c | sort -nr</code> :</p><blockquote><p>sort by the internet file descriptor, in reverse order</p></blockquote></li><li><p>Port status</p><p><code>lsof -nP -i:8081</code></p></li><li><p>QPS</p><p><code>grep -a "got job" notify_server.log | cut -c -19 | uniq -c</code></p></li></ul><h2 id=innotop>innotop<a href=#innotop class=hanchor arialabel=Anchor>&#8983;</a></h2><blockquote><p>The monitor tool for mysql</p></blockquote><ul><li>login:<code> innotop -uroot -p password</code></li></ul><h2 id=history>history<a href=#history class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li>execute comand by number line: <code>!number</code></li></ul><h2 id=scp>scp<a href=#scp class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li>repLocal to server (file): <code>scp path/file username@ip:/where/to/put</code></li><li>Local to server (dir): <code>scp -r path/file username@ip:/where/to/put</code></li></ul><p>##nohup</p><blockquote><p>run a command immune to hangups, with output to a non-tty</p></blockquote><h4 id=keep-process-running-when-ssh-log-out>keep process running when ssh log out<a href=#keep-process-running-when-ssh-log-out class=hanchor arialabel=Anchor>&#8983;</a></h4><p><code>nohup command &</code></p><h4 id=and-no-nohupout>and no <strong>nohup.out</strong><a href=#and-no-nohupout class=hanchor arialabel=Anchor>&#8983;</a></h4><p><code>nohup command > /dev/null 2>&amp;1 &</code></p><h2 id=ps>PS<a href=#ps class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li>To print a process tree: <code>ps axjf</code> (alse add some grep: <code>ps axjf | grep "keyname"</code>)</li></ul><h2 id=xargs>xargs<a href=#xargs class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li><p><strong>list files (exclude some files that you don&rsquo;t want) , then copy to some dictionary</strong></p><p><code>ls -S | grep -E -v 'GPNServer.log*' | xargs cp -r -t ../gpns_backup</code></p></li><li><p><strong>list process, then get the specific process that you want to kill, then kill</strong></p><p><code>ps aux | grep kafka_2 | grep server | awk {'print$2'} | xargs kill -9</code></p></li></ul><h2 id=find>find<a href=#find class=hanchor arialabel=Anchor>&#8983;</a></h2><p><code>find * -name filename</code></p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://jinying-che.github.io/posts/mac_setup/><span class=button__icon>←</span>
<span class=button__text>Mac Setup</span></a></span>
<span class="button next"><a href=https://jinying-che.github.io/posts/algorithm/dynamic_programming/><span class=button__text>Dynamic Programming</span>
<span class=button__icon>→</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2023 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>