<!doctype html><html lang=en><head><title>MySQL ::</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="MySQL Overview"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://jinying-che.github.io/posts/mysql/><link rel=stylesheet href=https://jinying-che.github.io/styles.css><link rel="shortcut icon" href=https://jinying-che.github.io/img/theme-colors/green.png><link rel=apple-touch-icon href=https://jinying-che.github.io/img/theme-colors/green.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="MySQL"><meta property="og:description" content="MySQL Overview"><meta property="og:url" content="https://jinying-che.github.io/posts/mysql/"><meta property="og:site_name" content><meta property="og:image" content="https://jinying-che.github.io/img/favicon/green.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2019-06-05 11:48:53 +0800 +0800"></head><body class=green><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>jinying-che:~#</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/posts>Home</a></li><li><a href=/tags>Tags</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/posts>Home</a></li><li><a href=/tags>Tags</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://jinying-che.github.io/posts/mysql/>MySQL</a></h1><div class=post-meta><time class=post-date>2019-06-05 ::</time></div><span class=post-tags>#<a href=https://jinying-che.github.io/tags/database/>database</a>&nbsp;
#<a href=https://jinying-che.github.io/tags/mysql/>mysql</a>&nbsp;</span><div class=post-content><div><blockquote><p>mysql，在InnoDB引擎的背景下</p></blockquote><h2 id=随想>随想<a href=#随想 class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li>每碰到一个新数据库，我们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景</li></ul><h2 id=索引>索引<a href=#索引 class=hanchor arialabel=Anchor>&#8983;</a></h2><h4 id=b树>B+树<a href=#b树 class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>使用m叉树，而不是二叉树，是因为树的高度，代表了访问的次数，而数据库是需要访问磁盘的，访问成本高，减少树的高度，就是减少访问磁盘的次数</li></ul><h4 id=类型>类型<a href=#类型 class=hanchor arialabel=Anchor>&#8983;</a></h4><h5 id=主键维度>主键维度<a href=#主键维度 class=hanchor arialabel=Anchor>&#8983;</a></h5><ul><li><p>聚簇索引(clustered index)，也叫主键索引，叶子节点存储整行数据。</p></li><li><p>非主键索引，也叫二级索引(secondary index)，二级索引存储的是主键的值。</p><blockquote><p>回表：根据普通索引查询，需要先查询二级索引树，得到主键值，再查询主键索引树，这个过程既是回表。</p></blockquote></li></ul><h5 id=唯一性维度>唯一性维度<a href=#唯一性维度 class=hanchor arialabel=Anchor>&#8983;</a></h5><ul><li><p>唯一索引：建立索引的字段是唯一的</p></li><li><p>普通索引：不保证唯一</p><blockquote><p>查询过程：</p><ul><li>普通索引：查到满足条件的记录，继续查询(数据有序，顺序向后查询)</li><li>唯一索引：查到满足条件的记录，即退出</li></ul><p>性能几乎没有差距，InnoDB 的数据是按数据页为单位来读写的，一页有近千条数据，满足条件的记录分散在不同数据页的几率极低，所以"查找和判断下一条记录"的操作，只需要一次指针移动和一次计算，性能差距很小。</p></blockquote><blockquote><p>更新过程：</p><p>(如果能命中内存数据页，都是直接更新内存，行为相同，主要讨论不命中内存页的场景)</p><ul><li>普通索引：先更新到<code>change buffer</code>里，等目标的数据页因查询被更新到内存后，再进行merge操作</li><li>唯一索引：所有的更新操作都要先判断这个操作是否违反唯一性约束，所以不能使用<code>change buffer</code></li></ul></blockquote><blockquote><p>两者的选择：</p><ul><li>在业务允许的条件下，优先选择普通索引(可以利用到<code>change buffer</code>)</li><li>更新记录后，马上对其大量查询，应该关闭<code>change buffer</code></li></ul></blockquote></li></ul><h4 id=索引维护>索引维护<a href=#索引维护 class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li><p>页分裂：当插入一条数据时，数据所在的数据页已经满了，根据B+树的算法，会申请新的数据页，并挪动部分数据过去，性能自然会受到影响，利用率也会下降</p></li><li><p>页合并：页合并的逆过程，当相邻的两个页由于删除数据，利用率降低，会发生页合并</p><blockquote><ul><li>从性能角度：自增主键能够有效的降低页分裂</li><li>从存储角度：普通索引存储的是主键索引的值，主键索引占用空间越小，普通索引占用空间也就越小</li></ul><p>所以，尽量采用自增主键</p></blockquote></li></ul><h4 id=优化>优化<a href=#优化 class=hanchor arialabel=Anchor>&#8983;</a></h4><blockquote><ul><li>尽量少地访问资源，是数据库设计的重要原则之一</li><li>将数据从磁盘读入内存涉及随机 IO 的访问，是数据库里面成本最高的操作之一</li></ul></blockquote><ul><li>减少回表的次数，<strong>覆盖索引</strong>是一个常用的性能优化手段</li><li>最左匹配原则：在建立联合索引时，如果通过调整顺序，可以少维护一个索引，那么这个顺序有限考虑采用</li><li>而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</li></ul><h2 id=设计>设计<a href=#设计 class=hanchor arialabel=Anchor>&#8983;</a></h2><blockquote><p>Mysql可以分为Server层和存储引擎层</p><p><img src=https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png alt=img></p></blockquote><h3 id=数据页>数据页<a href=#数据页 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>InnoDB 的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在 InnoDB 中，每个数据页的大小默认是 16KB。</li></ul><h3 id=change-buffer>change buffer<a href=#change-buffer class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li><blockquote><p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性</p></blockquote></li><li><blockquote><p>change buffer 在内存中有拷贝，也会被写入到磁盘上</p></blockquote></li><li><blockquote><p>将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作</p></blockquote></li><li><blockquote><p>如果能够将更新操作先记录在 change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用 buffer pool 的，所以这种方式还能够避免占用内存，提高内存利用率</p></blockquote></li></ul><h3 id=一条查询语句的执行>一条查询语句的执行<a href=#一条查询语句的执行 class=hanchor arialabel=Anchor>&#8983;</a></h3><blockquote><p><strong>不建议开启查询缓存</strong>：查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的所有查询缓存都会被清空。</p></blockquote><p><code>查询</code>—><code>查询缓存命中即返回，否则继续</code>—><code>分析器</code>—><code>优化器</code>—><code>执行器</code>—><code>存储引擎</code></p><h3 id=一条更新语句的执行>一条更新语句的执行<a href=#一条更新语句的执行 class=hanchor arialabel=Anchor>&#8983;</a></h3><blockquote><p>注意：此处的数据页内存，是InnoDB控制，而不是在<strong>server层</strong>的查询缓存</p></blockquote><p><code>update T set c=c+1 where ID=2;</code></p><p>浅色框表示在InnoDB内部执行，深色框表示在执行器中执行</p><p><img src=https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png alt=img></p><h3 id=两阶段提交>两阶段提交<a href=#两阶段提交 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>为保证两份日志之间逻辑的一致性，需要两阶段提交，流程如上图所示：</p><ol><li>写入redo log, 处于<strong>prepare</strong>阶段</li><li>写入bin log</li><li>更新redo log为<strong>commit</strong>状态</li></ol><blockquote><p>崩溃分析：</p><ul><li>在1、2之间崩溃，发现没有commit，回滚数据，一致</li><li>在2、3之间崩溃，虽然没有commit，但满足prepare和binlog完整，所以重启恢复时会自动commit，一致</li></ul></blockquote><h3 id=wal>WAL<a href=#wal class=hanchor arialabel=Anchor>&#8983;</a></h3><blockquote><p>Write-Ahead Logging，先写日志，再写磁盘</p></blockquote><p>当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p><h2 id=日志>日志<a href=#日志 class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=redo-log>redo log<a href=#redo-log class=hanchor arialabel=Anchor>&#8983;</a></h3><blockquote><p>属于InnoDB引擎特有的日志，写入到磁盘</p></blockquote><ul><li><p>redo log是固定大小的，循环利用，<code>write pos</code>和<code>check point</code>之间是可以写入的空间，当空间不足时，<code>check point</code> 向后移动进行数据擦除，擦除前要将数据更新到数据文件。</p><p><img src=https://static001.geekbang.org/resource/image/16/a7/16a7950217b3f0f4ed02db5db59562a7.png alt=img></p></li><li><p>记录数据页的改动</p></li></ul><h3 id=binlog>binlog<a href=#binlog class=hanchor arialabel=Anchor>&#8983;</a></h3><blockquote><p>server层的日志，写入到磁盘</p></blockquote><ul><li>Binlog有两种模式，statement 格式的话是记sql语句， row格式会记录行的内容，记两条，更新前和更新后都有</li></ul><h3 id=undo-log>undo log<a href=#undo-log class=hanchor arialabel=Anchor>&#8983;</a></h3><blockquote><p>用于事务回滚</p></blockquote><h2 id=事务隔离>事务隔离<a href=#事务隔离 class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=概念>概念<a href=#概念 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>读未提交是指(read uncommitted)，一个事务还没提交时，它做的变更就能被别的事务看到。</li><li>读提交是指(read committed)，一个事务提交之后，它做的变更才会被其他事务看到。</li><li>可重复读是指(repeatable read)，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li><li>串行化(serializable)，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><h3 id=隔离的实现>隔离的实现<a href=#隔离的实现 class=hanchor arialabel=Anchor>&#8983;</a></h3><blockquote><ul><li>在mysql中，每条记录更新的同时，都会记录一条回滚操作</li><li>这是数据库多版本并发控制（MVCC）的基础</li><li>不同的视图，对应不同的版本</li></ul></blockquote><p>数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。</p><ul><li><p>在<strong>可重复读</strong>隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图</p></li><li><p>在<strong>读提交</strong>隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的</p><blockquote><p>比如：在每次select时，都会拿到最新的数据，即使在事务中，区别于</p></blockquote></li><li><p><strong>读未提交</strong>隔离级别下直接返回记录上的最新值，没有视图概念</p></li><li><p><strong>串行化</strong>隔离级别下直接用加锁的方式来避免并行访问</p></li></ul><h2 id=锁>锁<a href=#锁 class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=全局锁>全局锁<a href=#全局锁 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li><p>对整个数据库加锁，场景多事全库逻辑备份，命令是：<code>Flush tables with read lock (FTWRL)</code>，全局锁会锁住所有的更新操作，全库处于只读状态</p></li><li><p>前一种方式不优雅，可以在可重复读的级别下开启事务，拿到一致性的视图，由于MVCC(多版本控制)的支持，期间数据是可以正常更新的，但前提是引擎要支持这个隔离级别 (InnoDB支持，MyISAM不支持)</p></li><li><p>全库只读，还可以用<code>set global readonly=true</code>的方式，不建议的原因：</p><blockquote><ul><li>一是，在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大</li><li>二是，在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高</li></ul></blockquote></li></ul><h3 id=表锁>表锁<a href=#表锁 class=hanchor arialabel=Anchor>&#8983;</a></h3><blockquote><p>加表锁的场景： 给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据</p></blockquote><p>Mysql表级锁有两种：</p><ul><li><p>表锁</p><ul><li>语法：<code>lock table T read/write</code></li><li>分读锁、写锁：<ol><li>一个线程持有读锁，则其他线程可读，不可写</li><li>一个线程持有写锁，其他线程不可读、不可写</li></ol></li><li>断开：<ol><li>主动断开</li><li>客户端连接断开</li></ol></li></ul></li><li><p>元数据锁(meta data lock, MDL)</p><blockquote><p>不需要显示使用，访问时自动加锁</p><ul><li>当对一个表做增删改查操作的时候，加 MDL 读锁</li><li>当要对表做结构变更操作的时候，加 MDL 写锁</li></ul></blockquote><ul><li>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</li><li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行</li><li>事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。</li></ul><blockquote><p><strong>常见坑：给小表加字段，导致整个库挂，复盘如下：</strong></p><ul><li>一个长事务在执行读写操作(select * from T .. join.. join)，加MDL读锁</li><li>一个变更表操作到来，需要加MDL写锁，被长事务阻塞</li><li>后续读写操作均被上一个<strong>MDL</strong>写锁阻塞</li><li>这个表完全不可读写，整个库线程池打满，无法响应请求</li></ul><p><strong>解决：</strong></p><ul><li>变更表操作时，kill掉长事务</li><li>加写锁时，设置超时时间</li></ul><p>参考:</p><p><a href=https://time.geekbang.org/column/article/69862>https://time.geekbang.org/column/article/69862</a></p></blockquote></li></ul><h3 id=行锁>行锁<a href=#行锁 class=hanchor arialabel=Anchor>&#8983;</a></h3><h4 id=两阶段锁>两阶段锁<a href=#两阶段锁 class=hanchor arialabel=Anchor>&#8983;</a></h4><blockquote><p>锁多个行，语句顺序</p></blockquote><h4 id=死锁>死锁<a href=#死锁 class=hanchor arialabel=Anchor>&#8983;</a></h4><h4 id=mvcc中的快照>MVCC中的快照<a href=#mvcc中的快照 class=hanchor arialabel=Anchor>&#8983;</a></h4><h4 id=事务id>事务ID<a href=#事务id class=hanchor arialabel=Anchor>&#8983;</a></h4><h4 id=当前读>当前读<a href=#当前读 class=hanchor arialabel=Anchor>&#8983;</a></h4><h2 id=分库分表>分库分表<a href=#分库分表 class=hanchor arialabel=Anchor>&#8983;</a></h2><h2 id=command>Command<a href=#command class=hanchor arialabel=Anchor>&#8983;</a></h2><h4 id=innodb-buffer>innodb buffer<a href=#innodb-buffer class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li><code>show global variables like 'innodb_buffer_pool_size';</code></li><li><code>set global innodb_buffer_pool_size=512000000;</code></li></ul></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://jinying-che.github.io/posts/network/https/><span class=button__icon>←</span>
<span class=button__text>HTTPS</span></a></span>
<span class="button next"><a href=https://jinying-che.github.io/posts/db/mysql_index/><span class=button__text>MySQL Index</span>
<span class=button__icon>→</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2023 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>