<!doctype html><html lang=en><head><title>Redis :: </title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Redis Overview"><meta name=keywords content="computer,ai,network"><meta name=robots content="noodp"><link rel=canonical href=https://jinying-che.github.io/posts/db/redis/><link rel=stylesheet href=https://jinying-che.github.io/styles.css><link rel="shortcut icon" href=https://jinying-che.github.io/img/theme-colors/green.png><link rel=apple-touch-icon href=https://jinying-che.github.io/img/theme-colors/green.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Redis"><meta property="og:description" content="Redis Overview"><meta property="og:url" content="https://jinying-che.github.io/posts/db/redis/"><meta property="og:site_name" content><meta property="og:image" content="https://jinying-che.github.io/img/favicon/green.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2019-09-16 17:37:10 +0800 +0800"></head><body class=green><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>jinying-che:~#</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/posts>Home</a></li><li><a href=/tags>Tags</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/posts>Home</a></li><li><a href=/tags>Tags</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://jinying-che.github.io/posts/db/redis/>Redis</a></h1><div class=post-meta><time class=post-date>2019-09-16 ::</time></div><span class=post-tags>#<a href=https://jinying-che.github.io/tags/database/>database</a>&nbsp;</span><div class=post-content><div><h2 id=data-structure>Data Structure<a href=#data-structure class=hanchor arialabel=Anchor>&#8983;</a></h2><p><img alt="redis data structure" src=/images/redis_data_structure.png></p><h2 id=redis配置>redis配置<a href=#redis配置 class=hanchor arialabel=Anchor>&#8983;</a></h2><ol><li><p>redis初始并不设置所用内存大小，默认会使用全部物理内存，但有<code>maxmemory</code>选项可以配置。</p><pre tabindex=0><code># In short... if you have slaves attached it is suggested that you set a lower
# limit for maxmemory so that there is some free RAM on the system for slave
# output buffers (but this is not needed if the policy is &#39;noeviction&#39;).
#
# maxmemory &lt;bytes&gt;
</code></pre></li></ol><h2 id=redis-命令>Redis 命令<a href=#redis-命令 class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li><p>###zrem</p><p>这个命令的返回值很特别：</p><ol><li>zset中存在的元素被删除，则返回1</li><li>zset中不存在的元素、不存在的zset的key，返回0</li><li>key存在，但不是zset类型，报错</li></ol></li></ul><p>##LUA</p><h2 id=碎片率>碎片率<a href=#碎片率 class=hanchor arialabel=Anchor>&#8983;</a></h2><blockquote><pre><code>出现高内存碎片问题的情况：大量的更新操作，比如append、setrange；大量的过期键删除，释放的空间无法得到有效利用 

解决办法：数据对齐，安全重启（高可用/主从切换）。
</code></pre></blockquote><h2 id=数据结构>数据结构<a href=#数据结构 class=hanchor arialabel=Anchor>&#8983;</a></h2><h4 id=列表list>列表（list）<a href=#列表list class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>压缩列表<ul><li>每个数据节点会记录：前一个节点的长度（previous_entry_length）、编码（encoding）、节点的值（content）</li></ul></li><li>双向循环链表<ul><li>会有单独的<strong>list</strong>的对象，来记录链表的<strong>头、尾、长度</strong>等信息</li></ul></li></ul><h4 id=字典hash>字典（hash）<a href=#字典hash class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li><p>压缩列表</p><ul><li>将健值对依次放入压缩列表，查询复杂度为0(n)，需要遍历</li></ul></li><li><p>散列表</p><blockquote><p><strong>解决冲突：<strong>通过链表法解决，每个数据节点都有</strong>next</strong>指针，冲突的节点会从头部插入</p><p><strong>rehash期间:</strong></p><ul><li>字典的删除、查找、更新，会在两个哈希表上进行，插入操作只会在新表上进行</li><li>渐进式rehash会维护一个游标（rehashidx），每次有请求时，会按顺序进行rehash，直到将旧的hash表重新映射到新的hash表</li><li>负载因子：在进行<strong>BGSAVE</strong>或者<strong>BGREWRITEAOF</strong>，会fork子进程来后台处理，大多数操作系统都是通过写时复制的策略，即子进程在读操作时，会共享而不复制父进程的内存，只有在写时，才会复制，所以在此期间会尽量控制写操作，减少内存的复制，因此负载因子会升高</li></ul></blockquote></li></ul><p>####集合 (set)</p><ul><li>有序数组</li><li>散列表</li></ul><h4 id=有序集合-sorted-set>有序集合 (sorted set)<a href=#有序集合-sorted-set class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>压缩列表</li><li>同时使用跳跃表和字典<ul><li>查询一组数据(zrange)利用跳跃表</li><li>查询单个数据用字典</li></ul></li></ul><h2 id=事务>事务<a href=#事务 class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li>redis的事务，是通过客户端的事务状态、服务端的队列，简单封装redis命令实现的</li><li>事务中的命令要不就全部执行，或者都不执行<ul><li>当入队的命令出错时，事务取消，都不执行</li><li>当部分命令失败时，继续执行<ul><li>redis不提供回滚机制</li><li>部分出错的命令结果会返回给客户端，客户端会根据错误情况进行处理，保证业务逻辑正确</li></ul></li></ul></li></ul><h2 id=rdb>RDB<a href=#rdb class=hanchor arialabel=Anchor>&#8983;</a></h2><h2 id=aof>AOF<a href=#aof class=hanchor arialabel=Anchor>&#8983;</a></h2><h2 id=referrence>Referrence<a href=#referrence class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li><a href=https://blog.bytebytego.com/p/why-is-redis-so-fast>https://blog.bytebytego.com/p/why-is-redis-so-fast</a></li></ul></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://jinying-che.github.io/posts/go/ratelimiter/><span class=button__icon>←</span>
<span class=button__text>How does golang implement the Rate Limiter</span>
</a></span><span class="button next"><a href=https://jinying-che.github.io/posts/network/https/><span class=button__text>HTTPS</span>
<span class=button__icon>→</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2024 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>