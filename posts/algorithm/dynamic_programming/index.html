<!doctype html><html lang=en><head><title>Dynamic Programming :: Terminal</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Dynamic Programming is simplifying a complicated problem by breaking it down into simpler sub-problems in a recursive manner"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://jinying-che.github.io/posts/algorithm/dynamic_programming/><link rel=stylesheet href=https://jinying-che.github.io/styles.css><link rel="shortcut icon" href=https://jinying-che.github.io/img/theme-colors/green.png><link rel=apple-touch-icon href=https://jinying-che.github.io/img/theme-colors/green.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Dynamic Programming"><meta property="og:description" content="Dynamic Programming is simplifying a complicated problem by breaking it down into simpler sub-problems in a recursive manner"><meta property="og:url" content="https://jinying-che.github.io/posts/algorithm/dynamic_programming/"><meta property="og:site_name" content="Terminal"><meta property="og:image" content="https://jinying-che.github.io/img/favicon/green.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2023-03-11 23:03:37 +0800 +0800"></head><body class=green><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>jinying-che:~#</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/posts>Home</a></li><li><a href=/tags>Tags</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/posts>Home</a></li><li><a href=/tags>Tags</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://jinying-che.github.io/posts/algorithm/dynamic_programming/>Dynamic Programming</a></h1><div class=post-meta><time class=post-date>2023-03-11 ::</time></div><span class=post-tags>#<a href=https://jinying-che.github.io/tags/algorithm/>algorithm</a>&nbsp;</span><div class=post-content><div><p>Dynamic Programming is mainly an optimization over plain recursion. Wherever we see a recursive solution that has repeated calls for the same inputs, we can optimize it using Dynamic Programming. The idea is to simply store the results of subproblems so that we do not have to re-compute them when needed later. This simple optimization reduces time complexities from exponential to polynomial</p><h2 id=two-key-attributes>Two Key Attributes<a href=#two-key-attributes class=hanchor arialabel=Anchor>&#8983;</a></h2><p>How to classify a problem as a Dynamic Programming algorithm Problem?</p><h4 id=1-overlapping-subproblems>1. Overlapping Subproblems<a href=#1-overlapping-subproblems class=hanchor arialabel=Anchor>&#8983;</a></h4><p>The solutions to the same subproblems are needed repetitively for solving the actual problem.</p><h4 id=2-optimal-substructure-property>2. Optimal Substructure Property<a href=#2-optimal-substructure-property class=hanchor arialabel=Anchor>&#8983;</a></h4><p>The solution to a given optimization problem can be obtained by the combination of optimal solutions to its sub-problems. Such optimal substructures are usually described by means of recursion.</p><blockquote><p>If a problem can be solved by combining optimal solutions to non-overlapping sub-problems, the strategy is called &ldquo;divide and conquer&rdquo; instead. This is why merge sort and quick sort are not classified as dynamic programming problems.</p></blockquote><h2 id=the-steps-to-resove-the-a-dynamic-programming-problem>The Steps To Resove The A Dynamic Programming Problem<a href=#the-steps-to-resove-the-a-dynamic-programming-problem class=hanchor arialabel=Anchor>&#8983;</a></h2><h4 id=1-identify-a-dp-problem-identify-the-subproblems>1. Identify a <strong>DP</strong> problem, Identify the <strong>subproblems</strong><a href=#1-identify-a-dp-problem-identify-the-subproblems class=hanchor arialabel=Anchor>&#8983;</a></h4><ol><li>refer to two key attributes</li><li>transfer the real world probelm to the math model, e.g. <a href=https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/>Best Time to Buy and Sell Stock</a>, actaully in the math world, which means to find the min and max value of the array, which is a significant dynamic problem flag.</li></ol><h4 id=2-decide-a-state-expression-with-the-least-parameters>2. Decide a state expression with the Least parameters<a href=#2-decide-a-state-expression-with-the-least-parameters class=hanchor arialabel=Anchor>&#8983;</a></h4><p>Determine what information you need to represent the solution to each subproblem. This is often done using a state vector or matrix.</p><h4 id=3-formulate-state-and-transition-relationships>3. Formulate state and transition relationships<a href=#3-formulate-state-and-transition-relationships class=hanchor arialabel=Anchor>&#8983;</a></h4><p>Determine the relationship between the solution to a subproblem and the solutions to its smaller subproblems. This is often done using a recursive formula or a set of rules.</p><h4 id=4-adding-memoization-or-tabulation-for-the-state>4. Adding memoization or tabulation for the state<a href=#4-adding-memoization-or-tabulation-for-the-state class=hanchor arialabel=Anchor>&#8983;</a></h4><p>Simply storing the state solution will allow us to access it from memory the next time that state is needed. Solve the subproblems in a bottom-up (tabulation) or top-down (memorization) manner.</p><h4 id=5-compute-the-final-solution-using-the-solutions-to-the-subproblems>5. Compute the final solution using the solutions to the subproblems.<a href=#5-compute-the-final-solution-using-the-solutions-to-the-subproblems class=hanchor arialabel=Anchor>&#8983;</a></h4><p>TODO: Example</p><h2 id=memoization-vs-tabulation-todo>memoization vs tabulation (TODO)<a href=#memoization-vs-tabulation-todo class=hanchor arialabel=Anchor>&#8983;</a></h2></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button next"><a href=https://jinying-che.github.io/posts/api_design/><span class=button__text>API Design</span>
<span class=button__icon>→</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2023 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>