---
title: "MySQL"
date: "2019-06-05T11:48:53+08:00"
tags: ["database"]
description: "MySQL Overview"
draft: true
---

> mysql，在InnoDB引擎的背景下

## 随想

- 每碰到一个新数据库，我们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景

## 索引

#### B+树

- 使用m叉树，而不是二叉树，是因为树的高度，代表了访问的次数，而数据库是需要访问磁盘的，访问成本高，减少树的高度，就是减少访问磁盘的次数



#### 类型

##### 主键维度

- 聚簇索引(clustered index)，也叫主键索引，叶子节点存储整行数据。

- 非主键索引，也叫二级索引(secondary index)，二级索引存储的是主键的值。

  > 回表：根据普通索引查询，需要先查询二级索引树，得到主键值，再查询主键索引树，这个过程既是回表。

##### 唯一性维度

- 唯一索引：建立索引的字段是唯一的

- 普通索引：不保证唯一

  > 查询过程：
  >
  > - 普通索引：查到满足条件的记录，继续查询(数据有序，顺序向后查询)
  > - 唯一索引：查到满足条件的记录，即退出
  >
  > 性能几乎没有差距，InnoDB 的数据是按数据页为单位来读写的，一页有近千条数据，满足条件的记录分散在不同数据页的几率极低，所以"查找和判断下一条记录"的操作，只需要一次指针移动和一次计算，性能差距很小。

  > 更新过程：
  >
  > (如果能命中内存数据页，都是直接更新内存，行为相同，主要讨论不命中内存页的场景)
  >
  > - 普通索引：先更新到`change buffer`里，等目标的数据页因查询被更新到内存后，再进行merge操作
  > - 唯一索引：所有的更新操作都要先判断这个操作是否违反唯一性约束，所以不能使用`change buffer`

  > 两者的选择：
  >
  > - 在业务允许的条件下，优先选择普通索引(可以利用到`change buffer`)
  > - 更新记录后，马上对其大量查询，应该关闭`change buffer`

#### 索引维护

- 页分裂：当插入一条数据时，数据所在的数据页已经满了，根据B+树的算法，会申请新的数据页，并挪动部分数据过去，性能自然会受到影响，利用率也会下降

- 页合并：页合并的逆过程，当相邻的两个页由于删除数据，利用率降低，会发生页合并

  > - 从性能角度：自增主键能够有效的降低页分裂
  > - 从存储角度：普通索引存储的是主键索引的值，主键索引占用空间越小，普通索引占用空间也就越小
  >
  > 所以，尽量采用自增主键

#### 优化

> - 尽量少地访问资源，是数据库设计的重要原则之一
> - 将数据从磁盘读入内存涉及随机 IO 的访问，是数据库里面成本最高的操作之一

- 减少回表的次数，**覆盖索引**是一个常用的性能优化手段
- 最左匹配原则：在建立联合索引时，如果通过调整顺序，可以少维护一个索引，那么这个顺序有限考虑采用
- 而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。



## 设计

> Mysql可以分为Server层和存储引擎层
>
> ![img](https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png)

### 数据页

- InnoDB 的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在 InnoDB 中，每个数据页的大小默认是 16KB。

### change buffer

- > 当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性

- > change buffer 在内存中有拷贝，也会被写入到磁盘上

- > 将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作

- > 如果能够将更新操作先记录在 change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用 buffer pool 的，所以这种方式还能够避免占用内存，提高内存利用率

### 一条查询语句的执行

> **不建议开启查询缓存**：查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的所有查询缓存都会被清空。

`查询`—>`查询缓存命中即返回，否则继续`—>`分析器`—>`优化器`—>`执行器`—>`存储引擎`

### 一条更新语句的执行

> 注意：此处的数据页内存，是InnoDB控制，而不是在**server层**的查询缓存

`update T set c=c+1 where ID=2;`

浅色框表示在InnoDB内部执行，深色框表示在执行器中执行

![img](https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png)

### 两阶段提交

为保证两份日志之间逻辑的一致性，需要两阶段提交，流程如上图所示：

1. 写入redo log, 处于**prepare**阶段
2. 写入bin log
3. 更新redo log为**commit**状态

> 崩溃分析：
>
> - 在1、2之间崩溃，发现没有commit，回滚数据，一致
> - 在2、3之间崩溃，虽然没有commit，但满足prepare和binlog完整，所以重启恢复时会自动commit，一致

### WAL

> Write-Ahead Logging，先写日志，再写磁盘

当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。



## 日志

### redo log

> 属于InnoDB引擎特有的日志，写入到磁盘

- redo log是固定大小的，循环利用，`write pos`和`check point`之间是可以写入的空间，当空间不足时，`check point` 向后移动进行数据擦除，擦除前要将数据更新到数据文件。

  ![img](https://static001.geekbang.org/resource/image/16/a7/16a7950217b3f0f4ed02db5db59562a7.png)

- 记录数据页的改动

### binlog

> server层的日志，写入到磁盘

- Binlog有两种模式，statement 格式的话是记sql语句， row格式会记录行的内容，记两条，更新前和更新后都有

### undo log

> 用于事务回滚

## 事务隔离

### 概念

- 读未提交是指(read uncommitted)，一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交是指(read committed)，一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读是指(repeatable read)，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
- 串行化(serializable)，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

### 隔离的实现

> - 在mysql中，每条记录更新的同时，都会记录一条回滚操作
> - 这是数据库多版本并发控制（MVCC）的基础
> - 不同的视图，对应不同的版本

数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。

- 在**可重复读**隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图

- 在**读提交**隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的

  > 比如：在每次select时，都会拿到最新的数据，即使在事务中，区别于

- **读未提交**隔离级别下直接返回记录上的最新值，没有视图概念

- **串行化**隔离级别下直接用加锁的方式来避免并行访问

## 锁

### 全局锁

- 对整个数据库加锁，场景多事全库逻辑备份，命令是：`Flush tables with read lock (FTWRL)`，全局锁会锁住所有的更新操作，全库处于只读状态
- 前一种方式不优雅，可以在可重复读的级别下开启事务，拿到一致性的视图，由于MVCC(多版本控制)的支持，期间数据是可以正常更新的，但前提是引擎要支持这个隔离级别 (InnoDB支持，MyISAM不支持)

- 全库只读，还可以用`set global readonly=true`的方式，不建议的原因：

  > - 一是，在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大
  > - 二是，在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高

### 表锁

> 加表锁的场景： 给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据

Mysql表级锁有两种：

- 表锁	

  - 语法：`lock table T read/write`
  - 分读锁、写锁：
    1. 一个线程持有读锁，则其他线程可读，不可写
    2. 一个线程持有写锁，其他线程不可读、不可写
  - 断开：
    1. 主动断开
    2. 客户端连接断开

- 元数据锁(meta data lock, MDL)

  > 不需要显示使用，访问时自动加锁
  >
  > - 当对一个表做增删改查操作的时候，加 MDL 读锁
  > - 当要对表做结构变更操作的时候，加 MDL 写锁

  - 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。
  - 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行
  - 事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。

  > **常见坑：给小表加字段，导致整个库挂，复盘如下：**
  >
  > - 一个长事务在执行读写操作(select * from T .. join.. join)，加MDL读锁
  > - 一个变更表操作到来，需要加MDL写锁，被长事务阻塞
  > - 后续读写操作均被上一个**MDL**写锁阻塞
  > - 这个表完全不可读写，整个库线程池打满，无法响应请求
  >
  > **解决：**
  >
  > - 变更表操作时，kill掉长事务
  > - 加写锁时，设置超时时间
  >
  > 参考:
  >
  > https://time.geekbang.org/column/article/69862

### 行锁

#### 两阶段锁

> 锁多个行，语句顺序

#### 死锁

#### MVCC中的快照

#### 事务ID

#### 当前读



## 分库分表



## Command

#### innodb buffer

- `show global variables like 'innodb_buffer_pool_size';`
- `set global innodb_buffer_pool_size=512000000;`
