<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>algorithm on Terminal</title><link>https://jinying-che.github.io/tags/algorithm/</link><description>Recent content in algorithm on Terminal</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sat, 11 Mar 2023 23:03:37 +0800</lastBuildDate><atom:link href="https://jinying-che.github.io/tags/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>Dynamic Programming</title><link>https://jinying-che.github.io/posts/algorithm/dynamic_programming/</link><pubDate>Sat, 11 Mar 2023 23:03:37 +0800</pubDate><guid>https://jinying-che.github.io/posts/algorithm/dynamic_programming/</guid><description>Dynamic Programming is mainly an optimization over plain recursion. Wherever we see a recursive solution that has repeated calls for the same inputs, we can optimize it using Dynamic Programming. The idea is to simply store the results of subproblems so that we do not have to re-compute them when needed later. This simple optimization reduces time complexities from exponential to polynomial
Two Key Attributes How to classify a problem as a Dynamic Programming algorithm Problem?</description><content>&lt;p>Dynamic Programming is mainly an optimization over plain recursion. Wherever we see a recursive solution that has repeated calls for the same inputs, we can optimize it using Dynamic Programming. The idea is to simply store the results of subproblems so that we do not have to re-compute them when needed later. This simple optimization reduces time complexities from exponential to polynomial&lt;/p>
&lt;h2 id="two-key-attributes">Two Key Attributes&lt;/h2>
&lt;p>How to classify a problem as a Dynamic Programming algorithm Problem?&lt;/p>
&lt;h4 id="1-overlapping-subproblems">1. Overlapping Subproblems&lt;/h4>
&lt;p>The solutions to the same subproblems are needed repetitively for solving the actual problem.&lt;/p>
&lt;h4 id="2-optimal-substructure-property">2. Optimal Substructure Property&lt;/h4>
&lt;p>The solution to a given optimization problem can be obtained by the combination of optimal solutions to its sub-problems. Such optimal substructures are usually described by means of recursion.&lt;/p>
&lt;blockquote>
&lt;p>If a problem can be solved by combining optimal solutions to non-overlapping sub-problems, the strategy is called &amp;ldquo;divide and conquer&amp;rdquo; instead. This is why merge sort and quick sort are not classified as dynamic programming problems.&lt;/p>
&lt;/blockquote>
&lt;h2 id="the-steps-to-resove-the-a-dynamic-programming-problem">The Steps To Resove The A Dynamic Programming Problem&lt;/h2>
&lt;h4 id="1-identify-a-dp-problem-identify-the-subproblems">1. Identify a &lt;strong>DP&lt;/strong> problem, Identify the &lt;strong>subproblems&lt;/strong>&lt;/h4>
&lt;ol>
&lt;li>refer to two key attributes&lt;/li>
&lt;li>transfer the real world probelm to the math model, e.g. &lt;a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/">Best Time to Buy and Sell Stock&lt;/a>, actaully in the math world, which means to find the min and max value of the array, which is a significant dynamic problem flag.&lt;/li>
&lt;/ol>
&lt;h4 id="2-decide-a-state-expression-with-the-least-parameters">2. Decide a state expression with the Least parameters&lt;/h4>
&lt;p>Determine what information you need to represent the solution to each subproblem. This is often done using a state vector or matrix.&lt;/p>
&lt;h4 id="3-formulate-state-and-transition-relationships">3. Formulate state and transition relationships&lt;/h4>
&lt;p>Determine the relationship between the solution to a subproblem and the solutions to its smaller subproblems. This is often done using a recursive formula or a set of rules.&lt;/p>
&lt;h4 id="4-adding-memoization-or-tabulation-for-the-state">4. Adding memoization or tabulation for the state&lt;/h4>
&lt;p>Simply storing the state solution will allow us to access it from memory the next time that state is needed. Solve the subproblems in a bottom-up (tabulation) or top-down (memorization) manner.&lt;/p>
&lt;h4 id="5-compute-the-final-solution-using-the-solutions-to-the-subproblems">5. Compute the final solution using the solutions to the subproblems.&lt;/h4>
&lt;p>TODO: Example&lt;/p>
&lt;h2 id="memoization-vs-tabulation-todo">memoization vs tabulation (TODO)&lt;/h2></content></item><item><title>Algorithm: How I leetcode</title><link>https://jinying-che.github.io/posts/algorithm/leetcode/</link><pubDate>Sat, 13 Feb 2021 16:31:28 +0800</pubDate><guid>https://jinying-che.github.io/posts/algorithm/leetcode/</guid><description>When do you play with leetcode? Personally, I open it only before the algorithm interview.
It&amp;rsquo;s wrong actually, the algorithm is not only used in the interview but also really useful in the production, which also make you write the effective code in the daily work. Leetcode helps interview a lot indeed, I sometimes can see some guys who get the Google offer by leetcode, moreover, I believe more algorithm we learned better engineer we can be.</description><content>&lt;p>When do you play with &lt;a href="https://leetcode.com/">leetcode&lt;/a>? Personally, I open it only before the algorithm interview.&lt;/p>
&lt;p>It&amp;rsquo;s wrong actually, the algorithm is not only used in the interview but also really useful in the production, which also make you write the effective code in the daily work. Leetcode helps interview a lot indeed, I sometimes can see some guys who get the Google offer by leetcode, moreover, I believe more algorithm we learned better engineer we can be.&lt;/p>
&lt;p>This post is showing that how I leetcode, it&amp;rsquo;s only my personal approach, I usually try to understand the one algorithm completely, then try to search by tag and resolve the problems from easy to hard.&lt;/p>
&lt;p>Enjoy the Algorithm, let&amp;rsquo;s leetcode!&lt;/p>
&lt;h3 id="data-structure">Data Structure&lt;/h3>
&lt;h4 id="array">Array&lt;/h4>
&lt;ul>
&lt;li>&lt;a href="https://leetcode.com/problems/first-missing-positive/">41. First Missing Positive&lt;/a> &amp;ndash; [&lt;a href="https://leetcode.com/problems/first-missing-positive/discuss/1076050/Golang41one-general-way-on-geek-way">discussion&lt;/a>]&lt;/li>
&lt;/ul>
&lt;h4 id="linked-list">Linked List&lt;/h4>
&lt;ul>
&lt;li>&lt;a href="https://leetcode.com/problems/reverse-linked-list/">206. Reverse Linked List&lt;/a> &amp;ndash; [&lt;a href="https://leetcode.com/problems/reverse-linked-list/discuss/1057045/golang206recursion-is-beautiful">discussion&lt;/a>]&lt;/li>
&lt;/ul>
&lt;h4 id="tree">Tree&lt;/h4>
&lt;ul>
&lt;li>&lt;a href="https://leetcode.com/problems/invert-binary-tree/">226. Invert Binary Tree&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">104. maximum-depth-of-binary-tree&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;blockquote>
&lt;p>The solutions for following three problems are similiar, which all base on the inorder traversal with stack&lt;/p>
&lt;p>&lt;a href="https://leetcode.com/problems/validate-binary-search-tree/discuss/32112/Learn-one-iterative-inorder-traversal-apply-it-to-multiple-tree-questions-(Java-Solution)">Discussion - Learn one iterative inorder traversal, apply it to multiple tree questions (Java Solution)&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;a href="https://leetcode.com/problems/binary-tree-inorder-traversal/">94. Binary Tree Inorder Traversal&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/validate-binary-search-tree/">98. Validate Binary Search Tree&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">230. Kth Smallest Element in a BST&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h4 id="heap">Heap&lt;/h4>
&lt;ul>
&lt;li>&lt;a href="https://leetcode.com/problems/top-k-frequent-elements/">347. Top K Frequent Elements&lt;/a> &amp;ndash; [&lt;a href="https://leetcode.com/problems/top-k-frequent-elements/discuss/1108972/Golang347-Implement-the-Min-Heap-on-my-own">disscussion: Implement the Min Heap on my own&lt;/a>]&lt;/li>
&lt;/ul>
&lt;h4 id="binary">Binary&lt;/h4>
&lt;p>To master binary related problems, understanding the binary operation is the key point: &lt;code>^&lt;/code>, &lt;code>|&lt;/code>, &lt;code>&amp;amp;&lt;/code>, &lt;code>&amp;gt;&amp;gt;&lt;/code> and &lt;code>&amp;lt;&amp;lt;&lt;/code>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://leetcode.com/problems/hamming-distance/description/">461. Hamming Distance&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="algorithm">Algorithm&lt;/h3>
&lt;h4 id="recursion">Recursion&lt;/h4>
&lt;ul>
&lt;li>&lt;a href="https://leetcode.com/problems/reverse-linked-list/">206. Reverse Linked List&lt;/a> &amp;ndash; [&lt;a href="https://leetcode.com/problems/reverse-linked-list/discuss/1057045/golang206recursion-is-beautiful">discussion&lt;/a>]&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/fibonacci-number/">509. Fibonacci Number&lt;/a> &amp;ndash; [&lt;a href="https://leetcode.com/problems/fibonacci-number/discuss/1057880/golang509four-ways-to-resolve-fibonacci-number">discussion&lt;/a>]&lt;/li>
&lt;/ul>
&lt;h4 id="dynamic-programming">Dynamic Programming&lt;/h4>
&lt;ul>
&lt;li>&lt;a href="https://leetcode.com/problems/fibonacci-number/">509. Fibonacci Number&lt;/a> &amp;ndash; [&lt;a href="https://leetcode.com/problems/fibonacci-number/discuss/1057880/golang509four-ways-to-resolve-fibonacci-number">discussion&lt;/a>]&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/climbing-stairs/">70. Climbing Stairs&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="binary-search">Binary Search&lt;/h4>
&lt;ul>
&lt;li>&lt;a href="https://leetcode.com/problems/binary-search/">704. Binary Search&lt;/a> &amp;ndash; [&lt;a href="https://leetcode.com/problems/binary-search/discuss/1055849/golang704beautiful-code-of-binary-search">discussion&lt;/a>]&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. Find First and Last Position of Element in Sorted Array&lt;/a> &amp;ndash; [&lt;a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/discuss/1056313/golang34easy-way-to-understand-with-two-binary-search">discussion&lt;/a>]&lt;/li>
&lt;/ul>
&lt;h4 id="quick-sort">Quick Sort&lt;/h4>
&lt;ul>
&lt;li>&lt;a href="https://leetcode.com/problems/kth-largest-element-in-an-array/">215. Kth Largest Element in an Array&lt;/a> &amp;ndash; &lt;a href="https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/1108891/Golang215two-partition-schema-of-quick-select">[discussion: two partition schema]&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/submissions/detail/465797355/">347. Top K Frequent Elements&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="greedy">Greedy&lt;/h4>
&lt;ul>
&lt;li>&lt;a href="https://leetcode.com/problems/partition-labels/">763. Partition Labels&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended/">1353. Maximum Number of Events That Can Be Attended&lt;/a> &amp;ndash; &lt;a href="https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended/solutions/4066650/1353-python-maximum-number-of-events-that-can-be-attended">[solution]&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="design">Design&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://leetcode.com/problems/lru-cache/">146. LRU Cache&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/lfu-cache/">460. LFU Cache&lt;/a> &amp;ndash; [&lt;a href="https://leetcode.com/problems/lfu-cache/discuss/1086255/Golang460two-ways-to-resolve-LFU-Cache">discussion&lt;/a>]&lt;/li>
&lt;/ul></content></item></channel></rss>