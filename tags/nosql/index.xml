<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>nosql on</title><link>https://jinying-che.github.io/tags/nosql/</link><description>Recent content in nosql on</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 16 Sep 2019 17:37:10 +0800</lastBuildDate><atom:link href="https://jinying-che.github.io/tags/nosql/index.xml" rel="self" type="application/rss+xml"/><item><title>Redis</title><link>https://jinying-che.github.io/posts/db/redis/</link><pubDate>Mon, 16 Sep 2019 17:37:10 +0800</pubDate><guid>https://jinying-che.github.io/posts/db/redis/</guid><description>Data Structure redis配置 redis初始并不设置所用内存大小，默认会使用全部物理内存，但有maxmemory选项可以配置。
# In short... if you have slaves attached it is suggested that you set a lower # limit for maxmemory so that there is some free RAM on the system for slave # output buffers (but this is not needed if the policy is &amp;#39;noeviction&amp;#39;). # # maxmemory &amp;lt;bytes&amp;gt; Redis 命令 ###zrem
这个命令的返回值很特别：
zset中存在的元素被删除，则返回1 zset中不存在的元素、不存在的zset的key，返回0 key存在，但不是zset类型，报错 ##LUA
碎片率 出现高内存碎片问题的情况：大量的更新操作，比如append、setrange；大量的过期键删除，释放的空间无法得到有效利用 解决办法：数据对齐，安全重启（高可用/主从切换）。 数据结构 列表（list） 压缩列表 每个数据节点会记录：前一个节点的长度（previous_entry_length）、编码（encoding）、节点的值（content） 双向循环链表 会有单独的list的对象，来记录链表的头、尾、长度等信息 字典（hash） 压缩列表</description><content>&lt;h2 id="data-structure">Data Structure&lt;/h2>
&lt;p>&lt;img src="https://jinying-che.github.io/images/redis_data_structure.png" alt="redis data structure">&lt;/p>
&lt;h2 id="redis配置">redis配置&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>redis初始并不设置所用内存大小，默认会使用全部物理内存，但有&lt;code>maxmemory&lt;/code>选项可以配置。&lt;/p>
&lt;pre tabindex="0">&lt;code># In short... if you have slaves attached it is suggested that you set a lower
# limit for maxmemory so that there is some free RAM on the system for slave
# output buffers (but this is not needed if the policy is &amp;#39;noeviction&amp;#39;).
#
# maxmemory &amp;lt;bytes&amp;gt;
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;h2 id="redis-命令">Redis 命令&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>###zrem&lt;/p>
&lt;p>这个命令的返回值很特别：&lt;/p>
&lt;ol>
&lt;li>zset中存在的元素被删除，则返回1&lt;/li>
&lt;li>zset中不存在的元素、不存在的zset的key，返回0&lt;/li>
&lt;li>key存在，但不是zset类型，报错&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;p>##LUA&lt;/p>
&lt;h2 id="碎片率">碎片率&lt;/h2>
&lt;blockquote>
&lt;pre>&lt;code>出现高内存碎片问题的情况：大量的更新操作，比如append、setrange；大量的过期键删除，释放的空间无法得到有效利用
解决办法：数据对齐，安全重启（高可用/主从切换）。
&lt;/code>&lt;/pre>
&lt;/blockquote>
&lt;h2 id="数据结构">数据结构&lt;/h2>
&lt;h4 id="列表list">列表（list）&lt;/h4>
&lt;ul>
&lt;li>压缩列表
&lt;ul>
&lt;li>每个数据节点会记录：前一个节点的长度（previous_entry_length）、编码（encoding）、节点的值（content）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>双向循环链表
&lt;ul>
&lt;li>会有单独的&lt;strong>list&lt;/strong>的对象，来记录链表的&lt;strong>头、尾、长度&lt;/strong>等信息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="字典hash">字典（hash）&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>压缩列表&lt;/p>
&lt;ul>
&lt;li>将健值对依次放入压缩列表，查询复杂度为0(n)，需要遍历&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>散列表&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>解决冲突：&lt;strong>通过链表法解决，每个数据节点都有&lt;/strong>next&lt;/strong>指针，冲突的节点会从头部插入&lt;/p>
&lt;p>&lt;strong>rehash期间:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>字典的删除、查找、更新，会在两个哈希表上进行，插入操作只会在新表上进行&lt;/li>
&lt;li>渐进式rehash会维护一个游标（rehashidx），每次有请求时，会按顺序进行rehash，直到将旧的hash表重新映射到新的hash表&lt;/li>
&lt;li>负载因子：在进行&lt;strong>BGSAVE&lt;/strong>或者&lt;strong>BGREWRITEAOF&lt;/strong>，会fork子进程来后台处理，大多数操作系统都是通过写时复制的策略，即子进程在读操作时，会共享而不复制父进程的内存，只有在写时，才会复制，所以在此期间会尽量控制写操作，减少内存的复制，因此负载因子会升高&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;p>####集合 (set)&lt;/p>
&lt;ul>
&lt;li>有序数组&lt;/li>
&lt;li>散列表&lt;/li>
&lt;/ul>
&lt;h4 id="有序集合-sorted-set">有序集合 (sorted set)&lt;/h4>
&lt;ul>
&lt;li>压缩列表&lt;/li>
&lt;li>同时使用跳跃表和字典
&lt;ul>
&lt;li>查询一组数据(zrange)利用跳跃表&lt;/li>
&lt;li>查询单个数据用字典&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="事务">事务&lt;/h2>
&lt;ul>
&lt;li>redis的事务，是通过客户端的事务状态、服务端的队列，简单封装redis命令实现的&lt;/li>
&lt;li>事务中的命令要不就全部执行，或者都不执行
&lt;ul>
&lt;li>当入队的命令出错时，事务取消，都不执行&lt;/li>
&lt;li>当部分命令失败时，继续执行
&lt;ul>
&lt;li>redis不提供回滚机制&lt;/li>
&lt;li>部分出错的命令结果会返回给客户端，客户端会根据错误情况进行处理，保证业务逻辑正确&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="rdb">RDB&lt;/h2>
&lt;h2 id="aof">AOF&lt;/h2>
&lt;h2 id="referrence">Referrence&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://blog.bytebytego.com/p/why-is-redis-so-fast">https://blog.bytebytego.com/p/why-is-redis-so-fast&lt;/a>&lt;/li>
&lt;/ul></content></item></channel></rss>