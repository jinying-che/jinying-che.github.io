<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>protocol on Terminal</title><link>https://jinying-che.github.io/tags/protocol/</link><description>Recent content in protocol on Terminal</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 21 Sep 2023 11:19:47 +0800</lastBuildDate><atom:link href="https://jinying-che.github.io/tags/protocol/index.xml" rel="self" type="application/rss+xml"/><item><title>HTTPS</title><link>https://jinying-che.github.io/posts/network/https/</link><pubDate>Thu, 21 Sep 2023 11:19:47 +0800</pubDate><guid>https://jinying-che.github.io/posts/network/https/</guid><description>TL;DR HTTPS = HTTP Over TLS, when we talk about HTTPS, we actually talk about the TLS more specifically.
Handshake The exact steps within a TLS handshake will vary depending upon the kind of key exchange algorithm used and the cipher suites supported by both sides. The RSA key exchange algorithm, while now considered not secure, was used in versions of TLS before 1.3.
Handshake TLS 1.2 Basically it&amp;rsquo;s a 3-Way TCP handshake + 4 Way TLS handshake.</description><content>&lt;h2 id="tldr">TL;DR&lt;/h2>
&lt;p>&lt;strong>HTTPS = HTTP Over TLS&lt;/strong>, when we talk about HTTPS, we actually talk about the TLS more specifically.&lt;/p>
&lt;h2 id="handshake">Handshake&lt;/h2>
&lt;p>The exact steps within a TLS handshake will vary depending upon the kind of key exchange algorithm used and the cipher suites supported by both sides. The RSA key exchange algorithm, while now considered not secure, was used in versions of TLS before 1.3.&lt;/p>
&lt;h4 id="handshake-tls-12">Handshake TLS 1.2&lt;/h4>
&lt;p>Basically it&amp;rsquo;s a &lt;em>3-Way TCP handshake&lt;/em> + &lt;em>4 Way TLS handshake&lt;/em>.
&lt;img src="https://jinying-che.github.io/images/https_handshake.png" alt="https handshake">&lt;/p>
&lt;pre tabindex="0">&lt;code> Client Server
-------------------- TCP 3-Way Handshke -----------------
SYNC
SYNC + ACK
ACK
-------------------- TLS 4-Way Handshake ---------------
ClientHello --------&amp;gt;
ServerHello
Certificate*
ServerKeyExchange*
CertificateRequest*
&amp;lt;-------- ServerHelloDone
Certificate*
ClientKeyExchange
CertificateVerify*
[ChangeCipherSpec]
Finished --------&amp;gt;
[ChangeCipherSpec]
&amp;lt;-------- Finished
Application Data &amp;lt;-------&amp;gt; Application Data
&lt;/code>&lt;/pre>&lt;p>Understand the classic handshake in 4 general steps:&lt;/p>
&lt;ol>
&lt;li>TCP Handshake&lt;/li>
&lt;li>Certificate Check (&lt;strong>TCP&lt;/strong>: client says hello, server says hello)&lt;/li>
&lt;li>Key Exchange (&lt;strong>Asymmetric Encryption&lt;/strong>)
Basically there&amp;rsquo;re two way for key exchange, the key point is how to generate the &lt;strong>premaster secret&lt;/strong> which is used to generate master secret which is used for data transmission eventually:
&lt;ol>
&lt;li>client generates the premaster secret key, encrypts by the public key, send to server (RSA algorithm)&lt;/li>
&lt;li>client and server generate the same premaster secret seperately using client and server params (ECDHE algorithm )&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Data Transmission (&lt;strong>Symmetric Encryption&lt;/strong>)&lt;/li>
&lt;/ol>
&lt;h4 id="handshake-tls-13">Handshake TLS 1.3&lt;/h4>
&lt;p>TBD&lt;/p>
&lt;h2 id="man-in-the-middle-attacker">Man-In-The-Middle Attacker&lt;/h2>
&lt;p>Assume there&amp;rsquo;s an attacker who can detect the info during the TLS handshake, trying to defend the attacker is a better way to understand the HTTPS design more throughly.&lt;/p>
&lt;ol>
&lt;li>Attacker is disguised as server? Use &lt;strong>Certificate Authority (CA)&lt;/strong> to validate the server&lt;/li>
&lt;li>Attacker steal the transmission key (master secret)? Use &lt;strong>Asymmetric Encryption (one way encryption)&lt;/strong>, even if attacker get the public key, still he&amp;rsquo;s not able to know what client sends to server (e.g. premaster secret) as only the private key can decrypt&lt;/li>
&lt;li>Attacker get the leaked private key? Use ECDHE algoritm to generate the premaster secret instead of passing from client to server.&lt;/li>
&lt;/ol>
&lt;h2 id="ssl-vs-tls">SSL vs TLS&lt;/h2>
&lt;p>SSL(Secure Sockets Layer) was the original security protocol developed for HTTP. SSL was replaced by TLS(Transport Layer Security) some time ago. SSL handshakes are now called TLS handshakes, although the &amp;ldquo;SSL&amp;rdquo; name is still in wide use.&lt;/p>
&lt;blockquote>
&lt;p>SSL v3.1 = TLS v1.0&lt;/p>
&lt;/blockquote>
&lt;h2 id="referrence">Referrence&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://blog.bytebytego.com/p/how-does-https-work-episode-6">https://blog.bytebytego.com/p/how-does-https-work-episode-6&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc5246">RFC5246: TLS1.2&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc8446">RFC8446: TLS1.3&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc2818">RFC2818: HTTPS&lt;/a>&lt;/li>
&lt;/ul></content></item></channel></rss>