<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Database on</title><link>https://chejinying.com/tech/tags/database/</link><description>Recent content in Database on</description><generator>Hugo</generator><language>en</language><lastBuildDate>Mon, 16 Sep 2019 17:37:10 +0800</lastBuildDate><atom:link href="https://chejinying.com/tech/tags/database/index.xml" rel="self" type="application/rss+xml"/><item><title>Redis</title><link>https://chejinying.com/tech/posts/db/redis/</link><pubDate>Mon, 16 Sep 2019 17:37:10 +0800</pubDate><guid>https://chejinying.com/tech/posts/db/redis/</guid><description>&lt;h2 id="data-structure"&gt;Data Structure&lt;/h2&gt;
&lt;p&gt;&lt;img src="https://chejinying.com/tech/images/redis_data_structure.png" alt="redis data structure"&gt;&lt;/p&gt;
&lt;h2 id="redis配置"&gt;redis配置&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;redis初始并不设置所用内存大小，默认会使用全部物理内存，但有&lt;code&gt;maxmemory&lt;/code&gt;选项可以配置。&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;# In short... if you have slaves attached it is suggested that you set a lower
# limit for maxmemory so that there is some free RAM on the system for slave
# output buffers (but this is not needed if the policy is &amp;#39;noeviction&amp;#39;).
#
# maxmemory &amp;lt;bytes&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="redis-命令"&gt;Redis 命令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;###zrem&lt;/p&gt;
&lt;p&gt;这个命令的返回值很特别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;zset中存在的元素被删除，则返回1&lt;/li&gt;
&lt;li&gt;zset中不存在的元素、不存在的zset的key，返回0&lt;/li&gt;
&lt;li&gt;key存在，但不是zset类型，报错&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##LUA&lt;/p&gt;
&lt;h2 id="碎片率"&gt;碎片率&lt;/h2&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;出现高内存碎片问题的情况：大量的更新操作，比如append、setrange；大量的过期键删除，释放的空间无法得到有效利用 

解决办法：数据对齐，安全重启（高可用/主从切换）。
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h2 id="数据结构"&gt;数据结构&lt;/h2&gt;
&lt;h4 id="列表list"&gt;列表（list）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;压缩列表
&lt;ul&gt;
&lt;li&gt;每个数据节点会记录：前一个节点的长度（previous_entry_length）、编码（encoding）、节点的值（content）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;双向循环链表
&lt;ul&gt;
&lt;li&gt;会有单独的&lt;strong&gt;list&lt;/strong&gt;的对象，来记录链表的&lt;strong&gt;头、尾、长度&lt;/strong&gt;等信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="字典hash"&gt;字典（hash）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;压缩列表&lt;/p&gt;</description></item><item><title>MySQL Index</title><link>https://chejinying.com/tech/posts/db/mysql_index/</link><pubDate>Wed, 05 Jun 2019 11:48:53 +0800</pubDate><guid>https://chejinying.com/tech/posts/db/mysql_index/</guid><description>&lt;p&gt;This post is based on MySQL &lt;strong&gt;InnoDB&lt;/strong&gt; Storage Engine.&lt;/p&gt;
&lt;h2 id="type"&gt;Type&lt;/h2&gt;
&lt;h4 id="1-cluster-index"&gt;1. Cluster Index&lt;/h4&gt;
&lt;p&gt;Each InnoDB table has a special index called the &lt;strong&gt;clustered index&lt;/strong&gt; that stores row data. Typically, the clustered index is synonymous with the &lt;strong&gt;primary key&lt;/strong&gt;.&lt;/p&gt;
&lt;h4 id="2-secondery-index"&gt;2. Secondery Index&lt;/h4&gt;
&lt;p&gt;In InnoDB, each record in a &lt;strong&gt;secondary index&lt;/strong&gt; contains the primary key columns for the row, as well as the columns specified for the secondary index. InnoDB uses this primary key value to search for the row in the clustered index.&lt;/p&gt;</description></item></channel></rss>